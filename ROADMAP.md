# 🗺️ 新手村技术路线指南

> 🎯 **不知道选哪条路？别担心，我们来帮你！**
> 
> 这张地图会带你找到最适合自己的起点。无论你选择哪条路，都是通往成功的正确选择！
> 
> 💡 **小提示**：openRuyi 使用 **glibc + RPM**。如果你想为后续参与开发积累最相关的经验，可以优先考虑 glibc 路线。但无论选择哪条路，你都能学到宝贵的系统构建技能！
>
> ⚠️ **代码示例声明**：本文所有命令与脚本片段均为实例，仅用于演示思路与路线差异。实际构建请结合你的环境做参数与路径修订。
>
> ✍️ **文档署名**：本文档由 **Avrova Donz** 借助 **ChatGPT 5.3** 完成。

---

## 🎯 路线总览

```
                        ┌─────────────────────────────────────┐
                        │         🏰 走出新手村                 │
                        │   (获得 openRuyi 内部账号)            │
                        │   目标：glibc + RPM                  │
                        └──────────────┬──────────────────────┘
                                       │
         ┌─────────────────────────────┼─────────────────────────────┐
         │                             │                             │
         ▼                             ▼                             ▼
┌─────────────────┐         ┌─────────────────┐         ┌─────────────────┐
│  📚 经典路线     │         │  🏭 完整路线     │         │  🚀 极速路线     │
│  ⭐ 推荐        │         │  ⭐⭐ 进阶       │         │  🎮 体验        │
│  (2-3天)        │         │  (3-5天)        │         │  (20分钟)        │
├─────────────────┤         ├─────────────────┤         ├─────────────────┤
│ • glibc         │         │ • glibc         │         │ • musl libc     │
│ • SysVinit      │         │ • systemd       │         │ • BusyBox init  │
│ • coreutils     │         │ • BLFS扩展      │         │ • 全静态链接      │
│ • 完整网络       │         │ • 开发环境       │         │ • 单二进制        │
│ • openRuyi基础  │         │ • 接近发行版      │         │ • 快速体验        │
└────────┬────────┘         └────────┬────────┘         └────────┬────────┘
         │                           │                           │
         ▼                           ▼                           ▼
┌─────────────────┐         ┌─────────────────┐         ┌─────────────────┐
│    Jvlegod      │         │    purofle      │         │  AvrovaDonz2026 │
│    的实践        │         │    的实践        │         │    的实践        │
└─────────────────┘         └─────────────────┘         └─────────────────┘
         │                           │
         └───────────────────────────┘
                     │
                     ▼
            ┌─────────────────┐
            │   openRuyi      │
            │   (glibc+RPM)   │
            └─────────────────┘
```

### 路线选择指南

| 路线 | 目标 | 与 openRuyi 的相关性 | 推荐度 |
|------|------|---------------------|--------|
| **📚 经典路线** | 掌握 glibc + 传统 Unix 工具 | ⭐⭐⭐⭐⭐ **直接相关** | ⭐⭐⭐⭐⭐ 首推 |
| **🏭 完整路线** | 掌握现代 Linux 系统构建 | ⭐⭐⭐⭐⭐ **直接相关** | ⭐⭐⭐⭐⭐ 首推 |
| **🚀 极速路线** | 快速体验 LFS 流程 | ⭐⭐ 仅作入门体验 | ⭐⭐ 可选 |

---

## 📚 经典路线 (glibc + SysVinit) ⭐ 推荐

**预计时间**：2-3天  
**代表人物**：Jvlegod  
**与 openRuyi 关系**：⭐⭐⭐⭐⭐ **最佳准备 —— openRuyi 同样使用 glibc**

### 这条路适合你，如果你...

- 📖 渴望深入理解传统 Unix 系统的运作机制
- 🛠️ 享受亲手构建每个组件的成就感
- 🎓 追求扎实、完整的学习体验
- 🔧 对经典 SysVinit 启动流程充满好奇
- 🎯 **想为参与 openRuyi 开发做最充分的准备**

**别担心难度！** 虽然需要 2-3 天，但每一步都有详细指导，遇到问题还有 FAQ 和社区支持。完成后的成就感是无与伦比的！

### 技术特点

| 特性 | 说明 |
|------|------|
| **C 库** | glibc 2.40 - **openRuyi 选择的 C 库** |
| **Init** | SysVinit 3.10 - 传统 Unix 启动 |
| **用户态** | GNU coreutils + bash + util-linux |
| **rootfs 大小** | ~100MB+ |
| **构建复杂度** | ⭐⭐⭐ 高 |
| **与 openRuyi 相关度** | ⭐⭐⭐⭐⭐ **直接相关** |

### 核心优势

1. **openRuyi 基础**：glibc 是 openRuyi 的核心组件，这条路线让你深入理解它
2. **最正统**：完全遵循 LFS 手册流程
3. **理解深**：每个包都亲手构建，理解依赖关系
4. **可扩展**：为后续 BLFS 和 RPM 包管理打下坚实基础

### 主要挑战

- 构建时间长（需要耐心）
- GCC 三阶段构建容易出错
- glibc 动态链接器路径复杂
- 权限管理需要细心

### 关键步骤

```bash
# Stage 1: 构建交叉编译器（无 libc）
# - binutils
# - GCC（最小化，仅 C 语言）

# Stage 2: 构建基础系统
# - Linux 头文件
# - glibc（完整 C 库）⭐ openRuyi 核心
# - GCC（完整版，支持 C++、线程）

# Stage 3: 构建用户态工具
# - bash（必须！否则 chroot 黑屏）
# - coreutils ⭐ openRuyi 基础工具
# - util-linux（mount, agetty 等）
# - SysVinit

# Stage 4: 配置启动
# - 创建 /etc/inittab
# - 配置 rc.d 脚本
# - 设置 fstab
```

### 常见问题

| 问题 | 解决方案 |
|------|----------|
| chroot 黑屏 | 忘记安装 bash！ |
| util-linux 安装报错 | 检查必要工具是否存在，可忽略 chgrp 错误 |
| GCC Stage 2 不完整 | 确保启用 `--enable-threads=posix --enable-shared` |
| 动态链接器找不到 | `ln -sv /usr/lib/ld-linux-riscv64-lp64d.so.1 ${CLFS}/lib/` |

### 实际案例

想了解这条路线的实际构建过程？查看已有提交：
- **Jvlegod** 的提交：`submissions/Jvlegod.md`
- 构建仓库：<https://github.com/Jvlegod/lfs-from-riscv>

---

## 🏭 完整路线 (glibc + systemd) ⭐⭐ 进阶推荐

**预计时间**：3-5天  
**代表人物**：purofle  
**与 openRuyi 关系**：⭐⭐⭐⭐⭐ **直接相关 —— 最接近现代发行版**

### 适合谁？

- 🖥️ 希望获得现代 Linux 体验
- 🌐 需要完整的网络功能
- 💼 计划开发软件包
- 🚀 追求与发行版一致的环境
- 🎯 **想全面掌握现代 Linux 系统**（推荐！）

### 技术特点

| 特性 | 说明 |
|------|------|
| **C 库** | glibc 2.42 - **openRuyi 选择的 C 库** |
| **Init** | systemd - 现代初始化系统 |
| **扩展** | BLFS - 网络、开发工具 |
| **rootfs 大小** | ~500MB+ |
| **构建复杂度** | ⭐⭐⭐⭐ 很高 |
| **与 openRuyi 相关度** | ⭐⭐⭐⭐⭐ **最接近目标系统** |

### 核心优势

1. **最接近 openRuyi**：体验与 Fedora/Ubuntu 类似的系统，openRuyi 也会是类似的现代系统
2. **功能全**：网络、SSH、开发环境齐全
3. **可开发**：可以直接在系统内编译软件
4. **为未来准备**：systemd 是现代发行版的标准

### 主要挑战

- QEMU 版本要求高（glibc 2.42 需要 QEMU patch）
- systemd 依赖众多，构建复杂
- 需要处理大量配置细节
- 时间投入最大

### 版本兼容性警告

⚠️ **重要**：glibc 2.42 与 QEMU 存在兼容性问题！

```bash
# 错误现象：程序运行时崩溃
# 原因：QEMU 不支持 termios2

# 解决方案 1：使用打补丁的 QEMU
# https://github.com/qemu/qemu/compare/v10.1.2...dramforever:qemu:add-termios2

# 解决方案 2：降级 glibc 到 2.40
```

### 网络配置

```bash
# QEMU 启动参数
-netdev user,id=net0 -device virtio-net-device,netdev=net0

# 系统内配置
ip link set eth0 up
dhcpcd eth0
```

### BLFS 扩展建议

完成基础 LFS 后，建议添加：

1. **网络基础**：dhcpcd, iproute2, curl
2. **证书**：make-ca（用于 https）
3. **开发工具**：cmake, git
4. **系统工具**：sudo, vim

### 实际案例

想了解这条路线的实际构建过程？查看已有提交：
- **purofle** 的提交：`submissions/purofle.md`
- 构建仓库：<https://github.com/purofle/riscv-lfs>

---

## 🚀 极速路线 (musl + BusyBox) 🎮 快速体验

**预计时间**：20分钟 ~ 2小时  
**代表人物**：AvrovaDonz2026  
**与 openRuyi 关系**：⭐⭐ **入门体验 —— 快速建立信心**

### 💡 这条路能带给你...

> **快速体验 LFS 的魅力，在 20 分钟内看到成果！**
> 
> 这条路线是绝佳的**入门选择**，让你快速理解 LFS 的基本流程，建立继续深入的信心。
> 
> **记住**：
> - musl 和 glibc 都是优秀的 C 库，各有特色
> - 如果你想为 openRuyi 做准备，后续可以尝试 glibc 路线
> - 无论如何，你学到的系统构建思想是通用的！

### 适合谁？

- ⏰ 时间极其有限，想先快速看到成果
- 🧠 想先理解最小系统的构成（作为预习）
- 🐳 对嵌入式/容器场景感兴趣（非 openRuyi 方向）
- 📝 喜欢简洁的文档

### 技术特点

| 特性 | 说明 |
|------|------|
| **C 库** | musl 1.2.5 - 轻量、静态链接友好 |
| **Init** | BusyBox init - 单二进制，极简 |
| **链接方式** | 全静态链接 - 无动态库依赖 |
| **rootfs 大小** | ~2-5MB |
| **构建复杂度** | ⭐ 低 |
| **与 openRuyi 相关度** | ⭐⭐ **技术栈不同** |

### 核心优势

1. **构建超快**：musl-cross-make 一键生成工具链
2. **理解直观**：没有复杂的动态链接问题
3. **体积超小**：适合嵌入式和容器场景
4. **问题少**：musl 设计简洁，坑少

### 主要挑战

- musl 与 glibc 有差异（如 NSS、locale）
- 全静态链接的 BusyBox 体积较大 (~1.5MB)
- 需要手动处理 musl 动态链接器路径
- 与 openRuyi 最终技术栈不同（openRuyi 使用 glibc）

### 快速开始

```bash
# 1. 安装 musl-cross-make
git clone https://github.com/richfelker/musl-cross-make.git
cd musl-cross-make

# 2. 配置（config.mak）
cat > config.mak << 'EOF'
TARGET = riscv64-linux-musl
OUTPUT = /mnt/lfs/tools
GCC_VER = 13.2.0
BINUTILS_VER = 2.42
MUSL_VER = 1.2.5
EOF

# 3. 构建
make -j$(nproc)

# 4. 构建 BusyBox（静态链接）
cd ..
wget https://busybox.net/downloads/busybox-1.36.1.tar.bz2
tar -xf busybox-1.36.1.tar.bz2
cd busybox-1.36.1

make defconfig
sed -i 's/CONFIG_TC=y/CONFIG_TC=n/' .config  # 禁用 tc
sed -i 's/# CONFIG_STATIC is not set/CONFIG_STATIC=y/' .config
make -j$(nproc)

# 5. 启动！（记住：这只是体验，最终还是要回归 glibc）
```

### 实际案例

想了解这条路线的实际构建过程？查看已有提交：
- **AvrovaDonz2026** 的提交：`submissions/AvrovaDonz2026.md`
- 构建仓库：<https://github.com/AvrovaDonz2026/lfs-riscv>

---

## 📚 更多案例

随着越来越多的同学完成试炼，`submissions/` 目录会积累丰富的实践案例。

**建议**：在选择路线前，可以先浏览几个提交，看看哪种风格更适合你。

---

## 🔄 进阶路径

### 推荐的学习路径

```
第一次尝试 LFS？
    │
    ├──► 🚀 极速路线（可选，20分钟建立信心）
    │         │
    │         ▼
    │    "原来 LFS 是这样！"
    │         │
    └─────────┤
              │
              ▼
    ┌─────────────────┐
    │  📚 经典路线     │ ◄── 推荐掌握！glibc + SysVinit
    │  (2-3天)        │     openRuyi 的基础
    └────────┬────────┘
             │
    ┌────────┴────────┐
    │                 │
    ▼                 ▼
┌─────────┐    ┌─────────────────┐
│直接参与  │    │  🏭 完整路线     │
│openRuyi │    │  (3-5天)        │
│基础开发  │    │  systemd + BLFS │
└─────────┘    │  现代发行版体验   │
               └────────┬────────┘
                        │
                        ▼
               ┌─────────────────┐
               │   参与 openRuyi  │
               │   高级开发       │
               └─────────────────┘
```

### 关于 musl 路线的重要说明

🚀 极速路线（musl）构建快速、问题少，是一个很好的 LFS 入门选择。openRuyi 选择 glibc 主要基于以下考虑：

| 对比项 | musl | glibc（openRuyi 使用） |
|--------|------|------------------------|
| **NSS 支持** | 有限 | 完整 |
| **locale** | 简化 | 完整 |
| **动态链接器** | 简单 | 复杂 |
| **软件兼容性** | 部分软件需适配 | 主流软件原生支持 |
| **RPM 包管理** | 非主流 | 标准支持 |

**选择建议**：
- 想**快速体验** LFS 流程 → musl 是个不错的起点  
- 想**参与 openRuyi 开发** → glibc 更有帮助  
- 想**挑战自我** → 两者都可以尝试，甚至对比它们的差异！

---

## 📝 各路线检查清单

### 📚 经典路线检查点（推荐）

- [ ] GCC 三阶段构建完成
- [ ] glibc 安装正确（动态链接器存在）⭐
- [ ] bash 和 coreutils 已安装
- [ ] chroot 环境可以进入
- [ ] SysVinit 配置完成
- [ ] 系统可以正常启动到登录提示

### 🏭 完整路线检查点（进阶）

- [ ] 基础 LFS 完成
- [ ] 网络配置完成（dhcpcd, iproute2）
- [ ] 可以访问外网（curl 测试）
- [ ] 安装了基本开发工具
- [ ] fastfetch 可以运行并截图

### 🚀 极速路线检查点（体验）

- [ ] musl-cross-make 成功生成工具链
- [ ] BusyBox 静态编译成功
- [ ] rootfs 可以打包并启动
- [ ] 能看到 shell 提示符
- [ ] **已完成体验，准备回归 glibc 路线** ⭐

---

## 💡 前辈寄语

**AvrovaDonz2026**（极速路线）：
> "不要被 LFS 的长篇文档吓到。先用 musl 快速获得一个可启动系统，建立信心后再深入 glibc。但记住，**最终还是要掌握 glibc**！"

**Jvlegod**（经典路线）：
> "手动构建每个包虽然费时，但当你理解为什么需要每个配置选项时，那种成就感是无与伦比的。**glibc 虽然复杂，但它是 Linux 发行版的标准。**"

**purofle**（完整路线）：
> "注意 QEMU 和 glibc 的版本兼容性！这个问题花了我一整天。**但掌握 glibc + 现代工具链，是参与 openRuyi 开发的必经之路。**"

---

## 📚 相关资源

- **实际案例**：查看 `submissions/` 目录下的提交
- **快速开始**：查看 [QUICKSTART.md](QUICKSTART.md)
- **问题排查**：查看 [FAQ.md](FAQ.md)

---

## 🎯 最终建议

| 你的情况 | 建议路线 | 理由 |
|----------|----------|------|
| 时间充裕，想认真参与 openRuyi | 📚 经典 或 🏭 完整 | 直接学习 glibc |
| 时间紧张，先建立信心 | 🚀 极速 → 📚 经典 | 先体验，再深入 |
| 想最快看到成果 | 🚀 极速（但要记住回归） | 快速体验 |
| 追求最完整的学习 | 🏭 完整 | 最接近发行版 |

**记住**：无论选择哪条路线，**glibc 是 openRuyi 的基石**，最终都要掌握！

*选择适合你的起点，但别忘了我们的终点是 glibc + RPM！* 🎯
